---
title: "Bônus - Prova 3"
author: "Mariana Costa Freitas"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = F, warning = F)
```

# Introdução

# Metodologia

# Análise dos dados

## Análise Descritiva

Para fazer uma de análise de dados completa, é necessário primeiro fazer uma análise descritiva dos dados, a fim de melhor compreender a sua natureza e, então, encontrar também um modelo adequado para descrever o conjunto de dados. A seguir, temos a apresentação de medidas de resumo para ambas as variáveis quantitativas e qualitativas relacionadas ao número de casos de câncer.

```{r}
#Carregando os dados
library(GLMsData)
library(janitor)
library(ggplot2)
library(MASS)
library(dplyr)
library(tidyverse)
library(patchwork)
library(flextable)

data(ccancer)
cancer <- ccancer |> clean_names()

resumo_quantitativas_flex <- function(df, variaveis) {
  df %>%
    select(all_of(variaveis)) %>%
    summarise(across(everything(), list(
      Média = mean,
      Mediana = median,
      Desvio_Padrão = sd,
      Mínimo = min,
      Q1 = ~quantile(.x, 0.25),
      Q3 = ~quantile(.x, 0.75),
      Máximo = max
    ))) %>%
    pivot_longer(everything(), names_to = c("Variável", "Métrica"), names_sep = "_") %>%
    pivot_wider(names_from = "Métrica", values_from = "value") %>%
    flextable() %>%
    set_header_labels(
      Variável = "Variável",
      Média = "Média",
      Mediana = "Mediana",
      Desvio_Padrão = "Desvio Padrão",
      Mínimo = "Mínimo",
      Q1 = "1º Quartil",
      Q3 = "3º Quartil",
      Máximo = "Máximo"
    ) %>%
    colformat_num(j = 2:8, digits = 2) %>%
    theme_vanilla() %>%
    autofit() 
}

resumo_quantitativas_flex(rename(cancer, `Número de casos de câncer` = count, `População` = population), c("Número de casos de câncer","População"))


# Função para resumo de variáveis qualitativas usando flextable

resumo_gender <- cancer |>
  mutate(contador = 1)|>
  group_by(gender) |>
  summarise(
    n = sum(contador),
    porc = sum(contador)/nrow(cancer)
  ) |>
  mutate(
    Categoria = case_when(
      gender == "M" ~ "Gênero: Masculino",
      gender == "F" ~ "Gênero: Femino"
    )
  ) |> select(-c(gender))
  

resumo_site <- cancer |>
  mutate(contador = 1)|>
  group_by(site) |>
  summarise(
    n = sum(contador),
    porc = sum(contador)/nrow(cancer)
  ) |>
  mutate(
    Categoria = case_when(
      site == "Lung" ~ "Local do câncer: Pulmão",
      site == "Colorectal" ~ "Local do câncer: Colo retal",
      site == "Breast" ~ "Local do câncer: Mama",
      site == "Prostate" ~ "Local do câncer: Próstata",
      site == "Pancreas" ~ "Local do câncer: Pâncreas"
    )
  ) |> select(-c(site))

resumo_region <- cancer |>
  mutate(contador = 1)|>
  group_by(region) |>
  summarise(
    n = sum(contador),
    porc = sum(contador)/nrow(cancer)
  ) |>
  mutate(
    Categoria = case_when(
      region == "Ontario" ~ "Região: Ontário",
      region == "Newfoundland" ~ "Região: Newfoundland",
      region == "Quebec" ~ "Região: Quebec"
    )
  ) |> select(-c(region))

resumo <- bind_rows(
  resumo_gender,
  resumo_site,
  resumo_region
)

# Criar a tabela com flextable
tabela <- flextable(resumo) %>%
  set_header_labels(
    Categoria = "Categoria",
    n = "Contagem",
    Proporcao = "Proporção (%)"
  ) %>%
  theme_vanilla() %>%
  autofit()

tabela


```

A partir da primeira tabela, é possível notar que o número de casos de câncer apresenta um alto desvio em comparação com a média, com 25% das contagens abaixo ou igual a 31.25 e 25% acima de 1212.5. Já a população ainda apresenta desvio alto, porém menor que a média, sendo que 25% dos dados tem população entre 533,800 e 25% acima de 11,874,400.0.  Na segunda tabela observamos que todas as variáveis quantitativas do conjunto de dados apresentam o mesmo número de observações por nível do fator.

A seguir, foi criado um gráfico de densidade para a variável de interesse, número de casos de câncer, a fim de melhor identificar um modelo adequado para os dados.

```{r}
ggplot(cancer, aes(x = count)) +
  geom_density(fill = "violet", alpha = 0.5, color = "violet") +
  labs(
    title = "Gráfico de Densidade do Número de Casos de Cãncer",
    x = "Número de Casos de Câncer",
    y = "Densidade"
  ) +
  theme_minimal()
```

A curva de densidade nos mostra que a distribuição apresenta uma assimetria à direita, que pode indicar que há uma presença de pequena concentração das observações em valores mais baixos, mas há também a presença de valores mais altos e alguns possíveis *outliers*, responsáveis pela longa cauda à direita. O gráfico condiz com a alta variabilidde dos dados de contagem mostrada nas anteriormente ao apresentar as medidas resumo da contagem.

Outra importante análise inicial, é observar como a variável de interesse, no caso, número de casos de câncer, se comporta em diferentes níveis ou valores do restante das variáveis. A seguir, os boxplots indicam essa relação de acordo com as variáveis qualitativas e o gráfico de dispersão com a única variável quantitativa, população. 

```{r}
b1 <- ggplot(cancer, aes(x = region, y = count, fill = region)) +
  geom_boxplot(alpha = 0.7) +  # Box plot com transparência 0.7
  labs(title = " ",
       x = "Região",
       y = "Número de Casos",
       fill = "Região") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Posiciona a legenda na parte inferior

b2 <- ggplot(cancer, aes(x = gender, y = count, fill = gender)) +
  geom_boxplot(alpha = 0.7) +  # Box plot com transparência 0.7
  labs(title = " ",
       x = "Gênero",
       y = "Número de Casos",
       fill = "Gênero") +
  theme_minimal() +
  theme(legend.position = "bottom")

b3 <- ggplot(cancer, aes(x = site, y = count, fill = site)) +
  geom_boxplot(alpha = 0.7) +  # Box plot com transparência 0.7
  labs(title = " ",
       x = "Local afetado",
       y = "Número de Casos",
       fill = "Local afetado") +
  theme_minimal() +
  theme(legend.position = "bottom")

library(patchwork)
combined_plot <- (b1 + b2) / (b3)
print(combined_plot)

options(scipen = 999)

# Criar o gráfico de dispersão com reta de regressão
ggplot(cancer, aes(x = population, y = count)) +
  geom_point(color = "black", alpha = 0.6) +  # Gráfico de dispersão
  labs(
    title = "Gráfico de Dispersão com Reta de Regressão",
    x = "População",
    y = "Número de Casos de Câncer"
  ) +
  theme_minimal()
```

```{r}
options(scipen = 999)

# Criar o gráfico de dispersão com reta de regressão
ggplot(cancer, aes(x = population, y = count)) +
  geom_point(color = "black", alpha = 0.6) +  # Gráfico de dispersão
  labs(
    title = "Gráfico de Dispersão com Reta de Regressão",
    x = "População",
    y = "Número de Casos de Câncer"
  ) +
  theme_minimal()
```


Analisando com base na região, notamos que Newfoundland apresenta uma média de casos de câncer extremamente baixa e variância também do número de casos de câncer bem baixa também; já Ontario e Quebec apresentam média do número de casos parecida, porém Ontario apresenta terceiro quartil mais alto e variãncia também mais elevada. Em relação ao gênero, as medidas do número de casos por gênero é bem parecida, com média e quartis bem próximos. Quanto ao local afetado pelo câncer, a maioria dos locais tem variabilidade baixa e quartis próximos, exceto o local Pulmão, com alta média e variabilidade quando comparada a outros grupos.

```{r}
library(knitr)
library(kableExtra)
library(flextable)
# Mostrando superdispersão
var_mpg <- cancer$count

# Calculando média e variância
stats_mpg <- data.frame(
  Estatística = c("Média", "Variância"),
  Valor = c(mean(var_mpg), var(var_mpg))
)

# Criando a tabela estilizada com flextable
flextable(stats_mpg) %>%
  set_caption("Média e Variância da variável 'mpg'") %>%
  colformat_num(j = 2, digits = 2) %>%
  autofit()
```


## Ajuste do modelo

```{r}

library(MASS)

# Modelo binomial negativo com função de ligação canônica
modelo_bn <- glm.nb(count ~ gender + region + site + population, 
                    data = cancer, link = "log")

modelo2 <- glm.nb(count ~ gender*site + region + population, 
                    data = cancer, link = "log")

# Obtendo o desvio do modelo
options(scipen = 999)
deviance(modelo_bn)
deviance(modelo2)

```
A função de ligação log é a mais comum e apropriada para modelos de contagem, como o binomial negativo, pois garante que os valores preditos sejam sempre positivos, o que faz sentido para variáveis de contagem. A função de ligação logit não é apropriada para variáveis de contagem, pois assume que a variável resposta está no intervalo (0, 1). A função de ligação probit é usada para respostas binárias ou proporcionais, assim como o logit. A função de ligação Complementay Log Log apresenta os mesmos problemas que a logit e probit. As funções de ligação identidade e raíz quadrática podem ser usadas para dados de contagem, porém não encontraram uma combinação de coeficientes válidos para ajuste do modelo. Assim, a única alterntiva foi a logarítmica.

Population foi removida nos modelos, pois apresenta colinearidade, ou seja, essa é altamente correlacionada com outras variáveis explicativas ou mesmo com a variável resposta.


```{r}
# Analisando como as variáveis dimunuem o desvio

fit0 <- glm.nb(count ~ 1, 
                    data = cancer, link = "log")

fit1 <-glm.nb(count ~ gender, 
                    data = cancer, link = "log")

fit2 <- glm.nb(count ~ gender + region + site, 
                    data = cancer, link = "log")

fit3 <- glm.nb(count ~ gender + region + site + population, 
                    data = cancer, link = "log")

fit4 <- glm.nb(count ~ gender*site + region + population, 
                    data = cancer, link = "log")

anova(fit0, fit1, fit2, fit3, fit4)
```

```{r}
# Interpretação dos coeficientes do modelo
coefficients(modelo2)
```

## Análise de resíduos

```{r}
# Carregar pacotes necessários
library(MASS)  # Para ajustar o modelo binomial negativo
library(car)   # Para gerar envelopes simulados

# Simular dados para um modelo binomial negativo
set.seed(2402)
n <- 100
x <- rnorm(n)
y <- rnbinom(n, size = modelo2$theta, mu = fitted(modelo2))  # Gerando dados de contagem

# Ajustar o modelo binomial negativo
modelo2 <- glm.nb(count ~ gender*site + region + population, link = log,
                  data = cancer)

# Função para gerar envelopes simulados
qqPlot(residuals(modelo2, type = "deviance"), 
        main = "", 
        xlab = "Percentil da N(0,1)", 
        ylab = "Componente do Desvio")

```

```{r}
fit.model <- modelo2

X <- model.matrix(fit.model)
n <- nrow(X)
p <- ncol(X)
w <- fit.model$weights
W <- diag(w)
H <- MASS::ginv(t(X)%*%W%*%X)
#H <- solve(t(X)%*%W%*%X)
H <- sqrt(W)%*%X%*%H%*%t(X)%*%sqrt(W)
h <- diag(H)
ts <- resid(fit.model,type="pearson")/sqrt(1-h)
td <- resid(fit.model,type="deviance")/sqrt(1-h)
di <- (h/(1-h))*(ts^2)
a <- min(td)
b <- max(td)
plot(fitted(fit.model), h,xlab="Valor Ajustado", ylab="Medida h",
pch=16)
#identify(fitted(fit.model), h, n=3)
```

```{r}
plot(di,xlab="Índice", ylab="Distância de Cook",
pch=16)
#identify(di, n=1)
```

```{r}
plot(td,xlab="Índice", ylab="Resíduo Componente do Desvio",
ylim=c(a-1,b+1), pch=16)
abline(2,0,lty=2)
abline(-2,0,lty=2)
#identify(td, n=1)
```

```{r}
w <- fit.model$weights
eta <- predict(fit.model)
z <- eta + resid(fit.model, type="pearson")/sqrt(w)
plot(predict(fit.model),z,xlab="Preditor Linear", 
ylab="Variavel z", pch=16)
lines(smooth.spline(predict(fit.model), z, df=2))
```







